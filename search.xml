<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计网基础知识</title>
      <link href="/2024/09/13/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/13/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="#_label0">1. 网络层次划分</a></li><li><a href="#_label1">2. OSI七层网络模型</a></li><li><a href="#_label2">3. IP地址</a></li><li><a href="#_label3">4. 子网掩码及网络划分</a></li><li><a href="#_label4">5. ARP&#x2F;RARP协议</a></li><li><a href="#_label5">6. 路由选择协议</a></li><li><a href="#_label6">7. TCP&#x2F;IP协议</a></li><li><a href="#_label7">8. UDP协议</a>　</li><li><a href="#_label8">9. DNS协议</a></li><li><a href="#_label9">10. NAT协议</a></li><li><a href="#_label10">11. DHCP协议</a></li><li><a href="#_label11">12. HTTP协议</a></li><li><a href="#_label12">13. 一个举例</a></li></ul><p>计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。</p><p>计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP&#x2F;IP标准网络协议。目前TCP&#x2F;IP协议已经成为Internet中的”通用语言”，下图为不同计算机群之间利用TCP&#x2F;IP进行通信的示意图。</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3401-20150904094424185-2018280216.gif"></p><h3 id="1-网络层次划分"><a href="#1-网络层次划分" class="headerlink" title="1. 网络层次划分"></a><strong>1. 网络层次划分</strong></h3><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的OSI&#x2F;RM模型（Open System Interconnection&#x2F;Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p><p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP&#x2F;IP四层协议以及TCP&#x2F;IP五层协议，它们之间的对应关系如下图所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-7490-20150904094019903-1923900106.jpg"></p><h3 id="2-OSI七层网络模型"><a href="#2-OSI七层网络模型" class="headerlink" title="2. OSI七层网络模型"></a>2. OSI七层网络模型</h3><p>TCP&#x2F;IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP&#x2F;IP协议。不管是OSI七层模型还是TCP&#x2F;IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif"></p><p><strong>1）物理层（Physical Layer）</strong></p><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p><p><strong>2）数据链路层（Data Link Layer）</strong></p><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><p>有关数据链路层的重要知识点：</p><ul><li><p><strong>1&gt; 数据链路层为网络层提供可靠的数据传输；</strong></p></li><li><p>　　<strong>2&gt; 基本数据单位为帧；</strong></p></li><li><p>　　<strong>3&gt; 主要的协议：以太网协议；</strong></p></li><li><p>　　<strong>4&gt; 两个重要设备名称：网桥和交换机。</strong></p></li><li><p><strong>3）网络层（Network Layer）</strong></p></li></ul><p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是”路径选择、路由及逻辑寻址”。</p><p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP&#x2F;IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p><ul><li><p>　　<strong>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></p></li><li><p>　　<strong>2&gt; 基本数据单位为IP数据报；</strong></p></li><li><p>　　<strong>3&gt; 包含的主要协议：</strong></p></li><li><p>　　<strong>IP协议（Internet Protocol，因特网互联协议）;</strong></p></li><li><p>　　<strong>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</strong></p></li><li><p>　　<strong>ARP协议（Address Resolution Protocol，地址解析协议）;</strong></p></li><li><p>　　<strong>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</strong></p></li><li><p>　　<strong>4&gt; 重要的设备：路由器。</strong></p></li></ul><p><strong>4）传输层（Transport Layer）</strong></p><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 有关网络层的重点：</p><ul><li>1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</li><li>2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；</li><li>3&gt; 重要设备：网关。</li></ul><p><strong>5）会话层</strong></p><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><p><strong>6）表示层</strong></p><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><p><strong>7）应用层</strong></p><p>为操作系统或网络应用程序提供访问网络服务的接口。</p><p>会话层、表示层和应用层重点：</p><ul><li><strong>1&gt; 数据传输基本单位为报文；</strong></li><li><strong>2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</strong></li></ul><h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3. IP地址"></a>3. IP地址</h3><p><strong>1）网络地址</strong></p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p><strong>2）广播地址</strong></p><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p><strong>3）组播地址</strong></p><p>D类地址就是组播地址。</p><p>先回忆下A，B，C，D类地址吧：</p><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(<strong>modified @2016.05.31</strong>)</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>4）255.255.255.255</strong></p><p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1&#x2F;30上的直接广播数据包后，另外一个网段192.168.1.5&#x2F;30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p><strong>5）0.0.0.0</strong></p><p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p><strong>6）回环地址</strong></p><p>127.0.0.0&#x2F;8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><p><strong>7）A、B、C类私有地址</strong></p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0&#x2F;8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0&#x2F;12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0&#x2F;16，范围是：192.168.0.0~192.168.255.255</p><h3 id="4-子网掩码及网络划分"><a href="#4-子网掩码及网络划分" class="headerlink" title="4. 子网掩码及网络划分"></a>4. 子网掩码及网络划分</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p><strong>什么是子网掩码？</strong></p><p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p><p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即” 0”地址和广播地址，它们是指主机地址或网络地址全为” 0”或” 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><p><strong>子网掩码的计算：</strong></p><p>对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p><p>下面总结一下有关子网掩码和网络划分常见的面试考题：</p><p>　　<strong>1）利用子网数来计算</strong></p><p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><p>(1) 将子网数目转化为二进制来表示;</p><p>如欲将B类IP地址168.195.0.0划分成27个子网：27&#x3D;11011；</p><p>(2) 取得该二进制的位数，为N；</p><p>该二进制为五位数，N &#x3D; 5</p><p>(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。</p><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p><p><strong>2）利用主机数来计算</strong></p><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><p>(1) 将主机数目转化为二进制来表示；</p><p>700&#x3D;1010111100</p><p>(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；</p><p>该二进制为十位数，N&#x3D;10；</p><p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p><p><strong>3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和****计算子网掩码。这也可按上述原则进行计算。</strong></p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><p>10＋1＋1＋1＝13</p><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网****络地址和广播地址。</strong></p><p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h3 id="5-ARP-RARP协议"><a href="#5-ARP-RARP协议" class="headerlink" title="5. ARP&#x2F;RARP协议"></a>5. ARP&#x2F;RARP协议</h3><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p>ARP工作流程举例：</p><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ul><li>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li><li>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li><li>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li><li>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ul><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>RARP协议工作流程：</p><ul><li>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>（4）如果不存在，RARP服务器对此不做任何的响应；</li></ul><h3 id="6-路由选择协议"><a href="#6-路由选择协议" class="headerlink" title="6. 路由选择协议"></a>6. 路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p><strong>RIP****协议</strong> ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF****协议</strong> ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h3 id="7-TCP-IP协议"><a href="#7-TCP-IP协议" class="headerlink" title="7. TCP&#x2F;IP协议"></a>7. TCP&#x2F;IP协议</h3><p><strong>TCP&#x2F;IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p><strong>TCP报文首部格式：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png"></p><p><strong>TCP协议的三次握手和四次挥手：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-7824-20150904110008388-1768388886.gif"></p><p>　　<strong>注：seq</strong>:”sequance”序列号；<strong>ack</strong>:”acknowledge”确认号；<strong>SYN</strong>:”synchronize”请求同步标志；<strong>；ACK</strong>:”acknowledge”确认标志”<strong>；****FIN</strong>：”Finally”结束标志。</p><p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p><p><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p><strong>为什么要三次握手？</strong></p><p>在只有两次”握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，”三次握手”很有必要！</p><p><strong>为什么要四次挥手？</strong></p><p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="8-UDP协议"><a href="#8-UDP协议" class="headerlink" title="8. UDP协议"></a>8. UDP协议</h3><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</strong></p><p>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>（1）源端口号；</li><li>（2）目标端口号；</li><li>（3）数据报长度；</li><li>（4）校验值。</li></ul><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p><p><strong>TCP</strong> <strong>与</strong> <strong>UDP</strong> <strong>的区别：</strong>TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p><h3 id="9-DNS协议"><a href="#9-DNS协议" class="headerlink" title="9. DNS协议"></a>9. DNS协议</h3><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP&#x2F;IP网络中，通过用户友好的名称查找计算机和服务。</p><h3 id="10-NAT协议"><a href="#10-NAT协议" class="headerlink" title="10. NAT协议"></a>10. NAT协议</h3><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h3 id="11-DHCP协议"><a href="#11-DHCP协议" class="headerlink" title="11. DHCP协议"></a>11. DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="12-HTTP协议"><a href="#12-HTTP协议" class="headerlink" title="12. HTTP协议"></a>12. HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。　　<strong>HTTP</strong> <strong>协议包括哪些请求？</strong></p><p>GET：请求读取由URL所标志的信息。</p><p>POST：给服务器添加信息（如注释）。</p><p>PUT：在给定的URL下存储一个文档。</p><p>DELETE：删除给定的URL所标志的资源。</p><p>　　<strong>HTTP</strong> <strong>中，</strong> <strong>POST</strong> <strong>与</strong> <strong>GET</strong> <strong>的区别</strong></p><ul><li><p>1）Get是从服务器上获取数据，Post是向服务器传送数据。</p></li><li><p>2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p></li><li><p>3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</p></li><li><p>4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p></li><li><p>I. 所谓 <strong>安全的</strong> 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p></li><li><p>II. <strong>幂等</strong> 的意味着对同一URL的多个请求应该返回同样的结果。</p></li></ul><h3 id="13-一个举例"><a href="#13-一个举例" class="headerlink" title="13. 一个举例"></a>13. 一个举例</h3><p>在浏览器中输入 <strong><a href="http://www.baidu.com/">http://www.baidu.com/</a></strong> 后执行的全部过程。</p><p>现在假设如果我们在客户端（客户端）浏览器中输入 <a href="http://www.baidu.com,/">http://www.baidu.com，</a> 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</p><ul><li>1）客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></li><li>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li></ul><blockquote><p>原文链接：<a href="http://www.cnblogs.com/maybe2030/p/4781555.html">http://www.cnblogs.com/maybe2030/p/4781555.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DHCP协议抓包分析</title>
      <link href="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DHCP完整过程详解及Wireshark抓包分析"><a href="#DHCP完整过程详解及Wireshark抓包分析" class="headerlink" title="DHCP完整过程详解及Wireshark抓包分析"></a>DHCP完整过程详解及Wireshark抓包分析</h1><h2 id="DHCP简介"><a href="#DHCP简介" class="headerlink" title="DHCP简介"></a>DHCP简介</h2><p>DHCP，Dynamic Host Configuration Protocol，<strong>动态</strong>主机配置协议，简单来说就是主机获取IP地址的过程，属于应用层协议。<br>DHCP采用UDP的67（服务器）和68（客户端）端口进行通信。</p><h2 id="报文协商过程"><a href="#报文协商过程" class="headerlink" title="报文协商过程"></a>报文协商过程</h2><p>DHCP过程主要为</p><p>​<strong>DHCP Discover</strong></p><p>​<strong>DHCP Offer</strong></p><p>​<strong>DHCP Request</strong></p><p>​<strong>DHCP Ack</strong></p><p>四个过程。</p><h2 id="Wireshark抓包"><a href="#Wireshark抓包" class="headerlink" title="Wireshark抓包"></a>Wireshark抓包</h2><p>通过Wireshark抓取DHCP获取IP过程的数据报文。</p><p>1、开Wireshark抓包</p><p>2、PC当前已有IP，使用cmd命令释放IP（ipconfig &#x2F;release)，并重新获取IP（ipconfig &#x2F;renew）</p><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><p>3、停止抓包，使用bootp过滤报文。</p><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><p>4、可以看到图中的5个报文，其中DHCP Release报文为PC释放IP时发出的报文。</p><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><h3 id="DHCP-Discover报文"><a href="#DHCP-Discover报文" class="headerlink" title="DHCP Discover报文"></a>DHCP Discover报文</h3><p>获取IP时，PC会发送DHCP Discover广播报文，由于当前PC没有IP，故源IP为0.0.0.0；特别要注意到的是，PC会随机出一个Transaction ID，如果之后收到的Offer报文中的Transaction ID与PC模拟出的不同，PC会将该Offer报文直接丢弃。</p><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><h3 id="DHCP-Offer报文"><a href="#DHCP-Offer报文" class="headerlink" title="DHCP Offer报文"></a>DHCP Offer报文</h3><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/5.png" class="" title="alt text"><h3 id="DHCP-Request报文"><a href="#DHCP-Request报文" class="headerlink" title="DHCP Request报文"></a>DHCP Request报文</h3><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/6.png" class="" title="alt text"><h3 id="DHCP-Ack报文"><a href="#DHCP-Ack报文" class="headerlink" title="DHCP Ack报文"></a>DHCP Ack报文</h3><img src="/2024/09/07/DHCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/7.png" class="" title="alt text"><p>【模拟服务器发送Offer报文的过程及注意事项】<br>1、保证服务器与客户端的连通性<br>2、准备好一个Offer报文（可编辑）<br>3、使用Wireshark抓取客户端发出的Discover报文，确定当前客户端随机出的Transaction ID<br>4、更改Offer报文中的Transaction ID与Discover报文中一致<br>5、使用发包软件发送Offer报文</p><p>注：Transaction ID</p><h2 id="【地址租期】"><a href="#【地址租期】" class="headerlink" title="【地址租期】"></a>【地址租期】</h2><p>DHCP服务器提供的每个IP地址都有相应的租用期，在Offer报文中的IP Address Lease Time中可以看到。地址租期时间过长会导致地址资源长期被占用，租期过短会导致DHCP请求包过多，增加网络负担。还要结合当前使用场景来设置。一般来说，对DHCP客户端数量较大，且断开网络比较频繁的场所，如机场、商铺等，一般把DHCP租期配置较短，这样IP地址能很快被回收。</p><h2 id="【IP续租过程】"><a href="#【IP续租过程】" class="headerlink" title="【IP续租过程】"></a>【IP续租过程】</h2><p>客户端会在地址租期还有1&#x2F;2的时候，向DHCP服务器发送DHCP Request报文；如果收到服务器的DHCP Ack后，客户端的IP地址租期重新回满。<br>如果未收到Ack，可继续使用该IP，在租期还有1&#x2F;4时发出第二次Request报文；如果收到Ack，租期回满；<br>如果未收到Ack，在租期还有1&#x2F;8时发出第三次Request报文，如果收到Ack，租期回满<br>如果未收到Ack，租期结束后IP被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章原文：https://www.cnblogs.com/Wendy-r/p/12679241.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络协议分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议抓包分析</title>
      <link href="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tcp协议的分析"><a href="#tcp协议的分析" class="headerlink" title="tcp协议的分析"></a>tcp协议的分析</h1><p>TCP（传输控制协议）是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。它主要用于在网络中实现可靠的数据传输。TCP协议的主要特点和功能包括：</p><ol><li><strong>连接导向</strong>：TCP在数据传输之前需要建立一个连接。这通过三次握手过程来完成，以确保两端的通信双方都准备好进行数据传输。</li><li><strong>可靠性</strong>：TCP提供数据传输的可靠性。它使用确认（ACK）机制来确保数据包被成功接收。如果发送方在超时时间内没有收到确认，它会重新发送数据包。</li><li><strong>数据流控制</strong>：TCP使用流量控制机制来避免接收方的缓冲区溢出。接收方会告知发送方它可以接收的数据量，从而避免数据发送过快。</li><li><strong>拥塞控制</strong>：TCP能够检测网络拥塞，并通过减少数据发送速率来减轻网络拥塞。这有助于防止网络过载和数据包丢失。</li><li><strong>数据顺序保证</strong>：TCP确保数据包按发送顺序到达接收方。如果数据包到达的顺序与发送顺序不一致，TCP会重新排序数据包。</li><li><strong>错误检测和修正</strong>：TCP对传输中的数据进行错误检测，并要求重新传输丢失或损坏的数据包。</li></ol><p>这些功能使得TCP适用于需要高可靠性的应用，如网页浏览、电子邮件和文件传输等。</p><h2 id="有哪些协议是基于TCP协议来设计的？"><a href="#有哪些协议是基于TCP协议来设计的？" class="headerlink" title="有哪些协议是基于TCP协议来设计的？"></a>有哪些协议是基于TCP协议来设计的？</h2><p>基于TCP协议制定的协议主要包括各种应用层协议，这些协议利用TCP提供的可靠、面向连接的数据传输特性来实现特定的网络功能。以下是一些基于TCP协议的常见协议：</p><ol><li><strong>HTTP（Hypertext Transfer Protocol）</strong>：<ul><li>用于在Web浏览器和Web服务器之间传输网页和其他资源。</li><li>支持请求和响应模型，如GET、POST、PUT、DELETE等方法。</li></ul></li><li><strong>HTTPS（Hypertext Transfer Protocol Secure）</strong>：<ul><li>HTTP的安全版本，通过SSL&#x2F;TLS加密传输数据，确保数据在传输过程中的机密性和完整性。</li></ul></li><li><strong>FTP（File Transfer Protocol）</strong>：<ul><li>用于在网络上进行文件传输和管理。</li><li>支持多种操作，包括上传、下载、删除和重命名文件。</li></ul></li><li><strong>SMTP（Simple Mail Transfer Protocol）</strong>：<ul><li>用于发送电子邮件。</li><li>定义了邮件的格式和传输规则，从客户端发送邮件到邮件服务器，然后再转发到目标邮件服务器。</li></ul></li><li><strong>IMAP（Internet Message Access Protocol）</strong>：<ul><li>用于从邮件服务器检索邮件。</li><li>支持在邮件服务器上管理邮件的文件夹和邮件状态。</li></ul></li><li><strong>POP3（Post Office Protocol version 3）</strong>：<ul><li>用于从邮件服务器下载邮件。</li><li>邮件下载到客户端后通常会从服务器上删除，适用于简单的邮件接收需求。</li></ul></li><li><strong>Telnet</strong>：<ul><li>用于远程登录到另一台计算机上进行命令行操作。</li><li>允许用户在远程计算机上执行命令和管理系统。</li></ul></li><li><strong>SSH（Secure Shell）</strong>：<ul><li>用于安全的远程登录和执行命令。</li><li>提供加密和认证功能，确保远程会话的安全性。</li></ul></li><li><strong>SFTP（Secure File Transfer Protocol）</strong>：<ul><li>基于SSH的文件传输协议。</li><li>提供安全的文件传输和管理功能。</li></ul></li><li><strong>RDP（Remote Desktop Protocol）</strong>：<ul><li>用于通过网络远程访问Windows计算机的桌面环境。</li><li>允许用户在远程计算机上进行图形用户界面的操作。</li></ul></li></ol><p>常用的电脑协议端口包括以下几种，涵盖了多种网络服务和应用：</p><h3 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h3><ul><li><strong>20&#x2F;21 - FTP（File Transfer Protocol）</strong><ul><li><strong>20</strong>：FTP数据传输端口（被动模式时使用）。</li><li><strong>21</strong>：FTP控制端口（用于建立和管理连接）。</li></ul></li><li><strong>22 - SSH（Secure Shell）&#x2F;SFTP（Secure File Transfer Protocol）</strong><ul><li><strong>22</strong>：用于安全的远程登录和文件传输。</li></ul></li><li><strong>23 - Telnet</strong><ul><li><strong>23</strong>：用于远程登录服务（不加密，通常不推荐用于安全敏感的环境）。</li></ul></li><li><strong>25 - SMTP（Simple Mail Transfer Protocol）</strong><ul><li><strong>25</strong>：用于发送电子邮件。</li></ul></li><li><strong>53 - DNS（Domain Name System）</strong><ul><li><strong>53</strong>：用于域名解析服务。</li></ul></li><li><strong>67&#x2F;68 - DHCP（Dynamic Host Configuration Protocol）</strong><ul><li><strong>67</strong>：DHCP服务器端口。</li><li><strong>68</strong>：DHCP客户端端口。</li></ul></li><li><strong>80 - HTTP（Hypertext Transfer Protocol）</strong><ul><li><strong>80</strong>：用于Web服务（非加密）。</li></ul></li><li><strong>110 - POP3（Post Office Protocol version 3）</strong><ul><li><strong>110</strong>：用于接收电子邮件。</li></ul></li><li><strong>143 - IMAP（Internet Message Access Protocol）</strong><ul><li><strong>143</strong>：用于接收和管理电子邮件。</li></ul></li><li><strong>443 - HTTPS（Hypertext Transfer Protocol Secure）</strong><ul><li><strong>443</strong>：用于加密的Web服务。</li></ul></li><li><strong>3389 - RDP（Remote Desktop Protocol）</strong><ul><li><strong>3389</strong>：用于远程桌面连接（Windows系统）。</li></ul></li></ul><h3 id="三次握手（Three-Way-Handshake）"><a href="#三次握手（Three-Way-Handshake）" class="headerlink" title="三次握手（Three-Way Handshake）"></a>三次握手（Three-Way Handshake）</h3><p>TCP协议在建立连接时使用三次握手过程，确保双方都准备好进行数据传输。三次握手的步骤如下：</p><ol><li><strong>SYN</strong>：客户端向服务器发送一个SYN（同步）报文段，请求建立连接。此报文段包含客户端的初始序列号。</li><li><strong>SYN-ACK</strong>：服务器收到客户端的SYN报文段后，回复一个SYN-ACK（同步-确认）报文段。此报文段包含服务器的初始序列号，并确认收到客户端的SYN报文段。</li><li><strong>ACK</strong>：客户端收到服务器的SYN-ACK报文段后，发送一个ACK（确认）报文段，确认收到服务器的SYN报文段。此时，连接建立完成，双方可以开始数据传输。</li></ol><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><h3 id="四次挥手（Four-Way-Handshake）"><a href="#四次挥手（Four-Way-Handshake）" class="headerlink" title="四次挥手（Four-Way Handshake）"></a>四次挥手（Four-Way Handshake）</h3><p>TCP连接的终止过程使用四次挥手，以确保双方都完成了数据传输并可以安全地关闭连接。四次挥手的步骤如下：</p><ol><li><strong>FIN</strong>：发送方（例如客户端）发送一个FIN（结束）报文段，表示它已经完成了数据传输，并且没有更多的数据要发送。此时，发送方进入<strong>FIN_WAIT_1</strong>状态。</li><li><strong>ACK</strong>：接收方（例如服务器）收到FIN报文段后，发送一个ACK（确认）报文段，确认接收方已经收到FIN报文段。此时，接收方进入CLOSE_WAIT状态，发送方进入<strong>FIN_WAIT_2</strong>状态。</li><li><strong>FIN</strong>：接收方完成它的所有数据传输后，发送一个FIN报文段，表示它也没有更多的数据要发送。此时，接收方进入<strong>LAST_ACK</strong>状态，发送方收到此FIN报文段后，进入TIME_WAIT状态。</li><li><strong>ACK</strong>：发送方收到接收方的FIN报文段后，发送一个ACK报文段，确认接收到接收方的FIN报文段。此时，接收方进入<strong>CLOSED</strong>状态，发送方在超时后也进入CLOSED状态，连接完全关闭。</li></ol><p><strong>（典型的TCP四次挥手）</strong></p><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一次挥手：想要关闭连接的一方（在这里是服务器）会发送一个FIN报文给另一方（物理机），表示它已经没有数据要发送了，并且想要关闭连接。这个FIN报文是从服务器的22端口发送到物理机的某个随机高位端口的。</span><br><span class="line"></span><br><span class="line">第二次挥手：物理机在收到服务器的FIN报文后，会发送一个ACK报文作为应答，表示它已经收到了服务器的FIN报文。这个ACK报文是从物理机的那个随机高位端口发送到服务器的22端口的。</span><br><span class="line"></span><br><span class="line">第三次挥手（如果有必要）：在某些情况下，物理机也可能想要关闭连接，这时它会发送一个FIN报文给服务器。但是，在正常的SSH会话退出过程中，这一步通常不会发生，因为物理机通常不会主动关闭连接，除非它遇到了某种错误或异常。然而，如果物理机确实发送了FIN报文，那么这个报文也是从物理机的随机高位端口发送到服务器的22端口的。</span><br><span class="line"></span><br><span class="line">第四次挥手：服务器在收到物理机的FIN报文（如果有的话）或确认物理机已经收到了自己的FIN报文后（通过物理机发送的ACK报文），会发送一个ACK报文给物理机，表示它也已经准备好了关闭连接。这个ACK报文是从服务器的22端口发送到物理机的随机高位端口的。</span><br></pre></td></tr></table></figure><p><strong>（非典型的TCP四次挥手）</strong></p><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><h2 id="为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？"><a href="#为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？" class="headerlink" title="为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？"></a>为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果你抓到的TCP四次挥手报文是由客户端（物理机）先发起的第一次挥手（即客户端发送FIN报文），那么这通常意味着SSH连接的关闭过程并非由服务器端的exit命令直接触发，而是由客户端或客户端上的某个进程/应用程序发起的。</span><br><span class="line"></span><br><span class="line">以下是一些可能导致客户端先发起FIN报文的原因：</span><br><span class="line"></span><br><span class="line">客户端主动关闭SSH会话：</span><br><span class="line">用户可能在客户端上使用了某种方式（如SSH客户端软件的关闭按钮、键盘快捷键、或执行了exit、logout等命令）来主动关闭SSH会话。这将导致客户端向服务器发送FIN报文来请求关闭TCP连接。</span><br><span class="line"></span><br><span class="line">客户端程序逻辑：</span><br><span class="line">如果SSH会话是由某个自动化脚本或程序启动的，并且该脚本或程序在完成其任务后包含了关闭SSH连接的逻辑，那么它可能会主动发送FIN报文来关闭连接。</span><br><span class="line"></span><br><span class="line">网络问题或中断：</span><br><span class="line">在极少数情况下，网络问题（如突然的网络断开、路由器故障等）可能导致TCP连接异常关闭，尽管这通常不会表现为标准的四次挥手过程。然而，如果客户端的网络堆栈检测到连接已经不可达，它可能会尝试发送FIN报文来优雅地关闭连接（尽管这通常不是网络问题导致的标准行为）。</span><br></pre></td></tr></table></figure><h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><ul><li><strong>SYN_SENT</strong>：连接请求已经发送，等待对方确认。</li><li><strong>SYN_RECEIVED</strong>：已经收到连接请求，并发送了确认。</li><li><strong>ESTABLISHED</strong>：连接已建立，可以进行数据传输。</li><li><strong>FIN_WAIT_1</strong>：等待对方确认连接关闭请求。</li><li><strong>FIN_WAIT_2</strong>：已经收到对方确认连接关闭请求，等待对方关闭连接。</li><li><strong>CLOSE_WAIT</strong>：对方关闭连接，等待应用程序关闭连接。</li><li><strong>LAST_ACK</strong>：等待对方确认最后一个关闭连接的请求。</li><li><strong>TIME_WAIT</strong>：等待足够的时间以确保对方收到关闭连接的确认。</li><li><strong>CLOSED</strong>：连接完全关闭。</li></ul><p>三次握手确保连接的双方能够可靠地建立通信，四次挥手确保连接能够被安全地关闭，避免数据丢失和资源浪费。</p><h2 id="wireshark抓包分析："><a href="#wireshark抓包分析：" class="headerlink" title="wireshark抓包分析："></a>wireshark抓包分析：</h2><p>​通过上面的阐述，我们可以了解到那些协议是基于TCP协议设计制定的。下面我们通过SSH连接来产生TCP报文，并通过wireshark来抓包分析其报文：</p><h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a><strong>三次握手：</strong></h4><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/5.png" class="" title="alt text"><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/6.png" class="" title="alt text"><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h4>]]></content>
      
      
      <categories>
          
          <category> 网络协议分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议抓包分析</title>
      <link href="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="icmp协议的分析"><a href="#icmp协议的分析" class="headerlink" title="icmp协议的分析"></a>icmp协议的分析</h2><p>ICMP（Internet Control Message Protocol，互联网控制报文协议）是网络设备用来发送错误消息和操作信息的协议，通常用于诊断网络连接问题。ICMP 是 TCP&#x2F;IP 协议族的一部分，主要用于主机与主机之间、主机与路由器之间以及路由器与路由器之间的通信。</p><h3 id="ICMP的主要功能"><a href="#ICMP的主要功能" class="headerlink" title="ICMP的主要功能"></a>ICMP的主要功能</h3><ol><li><strong>错误报告</strong>：<ul><li>当数据包不能到达目的地时，ICMP可以发送错误报告回源地址。例如，如果路由器找不到去往目的地的路由，它会发送一个“目标不可达”（Destination Unreachable）的ICMP消息。</li></ul></li><li><strong>网络诊断</strong>：<ul><li>ICMP常用于工具如<code>ping</code>和<code>traceroute</code>。<code>ping</code>使用ICMP回显请求和回显应答消息来检测网络连接是否可达，并测量往返时间。<code>traceroute</code>则通过逐步增加数据包的TTL（生存时间）来跟踪数据包的路径。</li></ul></li><li><strong>流量控制</strong>：<ul><li>ICMP可以发送“源抑制”（Source Quench）消息，通知发送方降低数据包发送速度，以避免网络过载。</li></ul></li></ol><h3 id="ICMP报文类型"><a href="#ICMP报文类型" class="headerlink" title="ICMP报文类型"></a>ICMP报文类型</h3><p>ICMP报文有多种类型，每种类型都有其特定的用途。常见的ICMP报文类型包括：</p><ul><li><strong>回显请求（Echo Request, 类型8）和回显应答（Echo Reply, 类型0）</strong>：用于<code>ping</code>操作。</li><li><strong>目标不可达（Destination Unreachable, 类型3）</strong>：表示数据包无法到达目的地。</li><li><strong>时间超时（Time Exceeded, 类型11）</strong>：用于指示数据包的TTL到达0时仍未到达目的地，一般在<code>traceroute</code>中使用。</li><li><strong>重定向（Redirect, 类型5）</strong>：通知主机应该使用另一条路由。</li></ul><h3 id="wireshark抓包分析"><a href="#wireshark抓包分析" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h3><p>我们可以在电脑的终端中ping我们的网关，再通过wireshark来抓到到icmp报文。</p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><p>wireshark抓包信息：</p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><p><strong>请求报文：</strong></p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><p><strong>应答报文：</strong></p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><p><strong>工作过程:</strong></p><p>本机发送一个 ICMP Echo Request 的包接受方返回一个ICMP Echo Reply，</p><p>包含了接受到数据拷贝和一些其他指令</p><h3 id="回显请求与应答报文的结构"><a href="#回显请求与应答报文的结构" class="headerlink" title="回显请求与应答报文的结构"></a>回显请求与应答报文的结构</h3><p>ICMP回显请求和应答报文的结构大致如下：</p><ul><li><strong>类型（Type）</strong>：8 表示回显请求，0 表示回显应答。</li><li><strong>代码（Code）</strong>：通常为 0。</li><li><strong>校验和（Checksum）</strong>：用于检测报文在传输中是否损坏。</li><li><strong>标识符（Identifier）</strong>：通常用来匹配请求和应答报文，允许区分不同的会话。</li><li><strong>序列号（Sequence Number）</strong>：用于跟踪报文的顺序，通常在多次请求中递增。</li><li><strong>数据（Data）</strong>：这是一个可选的填充字段，用于携带实际的数据。</li></ul><h3 id="数据字段的内容"><a href="#数据字段的内容" class="headerlink" title="数据字段的内容"></a>数据字段的内容</h3><p>在回显请求报文中，数据字段可以填充任何数据，常见的填充内容包括：</p><ul><li><strong>时间戳</strong>：用于计算往返时间。</li><li><strong>字符数据</strong>：例如，常见的填充数据为字符串，如“abcdefghijklmnopqrstuvwxyz”或简单的字节数据。</li><li><strong>随机数据</strong>：确保在网络传输中不会出现数据重复或重叠。<img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/5.png" class="" title="alt text"></li></ul><h2 id="icmp-中是如何来计算时间的？"><a href="#icmp-中是如何来计算时间的？" class="headerlink" title="icmp 中是如何来计算时间的？"></a>icmp 中是如何来计算时间的？</h2><p>ICMP 协议中的时间计算主要用于测量数据包在网络中的往返时间（Round-Trip Time, RTT），即一个 ICMP 回显请求（Echo Request）从发送到接收到相应的回显应答（Echo Reply）所经过的时间。这个时间的测量通常在网络诊断工具如 <code>ping</code> 中被使用。以下是 ICMP 中时间计算的过程：</p><h3 id="1-时间戳的记录"><a href="#1-时间戳的记录" class="headerlink" title="1. 时间戳的记录"></a>1. <strong>时间戳的记录</strong></h3><ul><li>当一个 ICMP 回显请求被发送时，发送方通常会在数据字段中记录一个时间戳。这通常是发送请求时的精确时间。</li><li>这个时间戳可以是系统的当前时间（例如以毫秒或微秒为单位的精确时间），具体格式取决于系统实现。</li></ul><h3 id="2-数据包的传输"><a href="#2-数据包的传输" class="headerlink" title="2. 数据包的传输"></a>2. <strong>数据包的传输</strong></h3><ul><li>ICMP 回显请求数据包从源主机发送到目标主机，经过可能的多个网络节点（如路由器）。</li><li>目标主机接收到请求后，会立即生成一个回显应答，将数据字段中的时间戳原封不动地返回给源主机。</li></ul><h3 id="3-应答的接收"><a href="#3-应答的接收" class="headerlink" title="3. 应答的接收"></a>3. <strong>应答的接收</strong></h3><ul><li><p>当源主机收到目标主机返回的 ICMP 回显应答时，它会读取应答报文中的时间戳。</p></li><li><p>计算RTT的方法是将当前时间与数据字段中的时间戳进行比较，即：</p><p>RTT&#x3D;接收应答的时间−发送请求的时间RTT &#x3D; \text{接收应答的时间} - \text{发送请求的时间}RTT&#x3D;接收应答的时间−发送请求的时间</p></li><li><p>这个时间差就是数据包在网络中的往返时间。</p></li></ul><h3 id="4-RTT-结果的显示"><a href="#4-RTT-结果的显示" class="headerlink" title="4. RTT 结果的显示"></a>4. <strong>RTT 结果的显示</strong></h3><ul><li><code>ping</code> 工具通常会显示每次请求的 RTT，以及多次请求的平均 RTT、最小 RTT 和最大 RTT。这些值可以帮助用户了解网络的性能和延迟情况。</li></ul><h4 id="TTL："><a href="#TTL：" class="headerlink" title="TTL："></a>TTL：</h4><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/6.png" class="" title="alt text"><h3 id="tracert-命令"><a href="#tracert-命令" class="headerlink" title="tracert 命令"></a>tracert 命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracert（trace Route）</span><br><span class="line">tracert + 设备ip</span><br></pre></td></tr></table></figure><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/7.png" class="" title="alt text"><p>如果数据包的跳数超过了设定的最大值（在 <code>tracert</code> 或 <code>traceroute</code> 命令中通常是 30 跳），则有几种可能的情况和影响：</p><ol><li><strong>路由环路</strong>：数据包可能进入一个环路状态，即它在两个或多个路由器之间不断循环。这会导致数据包永远不会到达目的地。</li><li><strong>目标不可达</strong>：如果数据包未能在最大跳数限制内到达目标，则认为目标网络不可达。这可能是由于网络配置错误或物理连接问题造成的。</li><li><strong>丢包</strong>：超过最大跳数的数据包通常会被网络中的一个路由器丢弃，并返回一个 ICMP 超时消息给发送者。</li><li><strong>延迟</strong>：数据包在多个跳数之间传输会导致增加的延迟，特别是在跨国或长距离的连接中。</li></ol><p><strong>一下tracert + 百度的公网IP：</strong></p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/8.png" class="" title="alt text"><p>从 <code>tracert</code> 输出中，我们可以看到：</p><ol><li>第一跳通过你的本地网关 <code>192.168.10.1</code>，延迟很低（2 毫秒）。</li><li>第二跳到达外部网络设备 <code>110.110.110.254</code>，延迟依旧非常低（平均约 2 毫秒）。</li><li>从第三跳开始，出现了请求超时，这表明数据包没有从下一个路由点成功返回，可能是因为网络配置问题、路由器故障或是某些网络设备配置了不响应 <code>tracert</code> 或 <code>ICMP</code> 请求。</li></ol><p>请求超时可能是因为：</p><ul><li>路由器或防火墙设置阻止了 ICMP 数据包。</li><li>网络链路故障或不稳定导致数据包无法传输。</li><li>路由配置问题导致数据包无法正确转发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络协议分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议抓包分析</title>
      <link href="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="wireshark-抓包分析"><a href="#wireshark-抓包分析" class="headerlink" title="wireshark 抓包分析"></a>wireshark 抓包分析</h1><h4 id="实战-使用-WireShark对常用协议抓包并分析原理"><a href="#实战-使用-WireShark对常用协议抓包并分析原理" class="headerlink" title="实战:使用 WireShark对常用协议抓包并分析原理"></a>实战:使用 WireShark对常用协议抓包并分析原理</h4><h3 id="1、常用协议分析"><a href="#1、常用协议分析" class="headerlink" title="1、常用协议分析"></a>1、常用协议分析</h3><p><strong>ARP 协议</strong></p><p>地址解析协议：(Address ResolutionProtocol，缩写:ARP)是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。<strong>ARP是通过网络地址（ip）来定位（确认）MAC地址。</strong></p><h3 id="一、ARP协议的基本概念"><a href="#一、ARP协议的基本概念" class="headerlink" title="一、ARP协议的基本概念"></a>一、ARP协议的基本概念</h3><ul><li><strong>定义</strong>：ARP协议是一个网络层协议，用于将网络层的IP地址解析成链路层的MAC地址，以便数据能在物理网络上正确传输。</li><li><strong>制定者</strong>：ARP协议由互联网工程任务组（IETF）在1982年11月发布的RFC 826中描述制定。</li><li><strong>作用</strong>：在TCP&#x2F;IP网络中，每个联网的主机都会被分配一个32位的IP地址，但为了让报文在物理网络上传输，还需要知道对方目的主机的物理地址（MAC地址）。ARP协议就是负责实现这一地址转换的。</li></ul><p><strong>抓包分析过程</strong></p><p>​过滤arp包：</p><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><h4 id="报文解析"><a href="#报文解析" class="headerlink" title="报文解析"></a>报文解析</h4><p>ARP（Address Resolution Protocol）协议的报文主要分为两种类型：<strong>ARP请求报文</strong>和<strong>ARP应答报文</strong>。下面我将分别举例分析这两种报文的结构和内容。</p><h5 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h5><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><h5 id="应答报文："><a href="#应答报文：" class="headerlink" title="应答报文："></a>应答报文：</h5><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><h5 id="总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。"><a href="#总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。" class="headerlink" title="总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。"></a>总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。</h5><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><p><strong>192.168.3.230广播:谁有 192.168.3.177 的 MAC地址?</strong></p><p><strong>192.168.3.177 应答:192.168.3.177 的 MAC 地址是 xxxxxxxxxxx</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建自己的博客</title>
      <link href="/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何来搭建自己的博客"><a href="#如何来搭建自己的博客" class="headerlink" title="如何来搭建自己的博客"></a>如何来搭建自己的博客</h1><p>​首先介绍介绍一下，本博客采用的是hexo框架搭配butterfly主题生成的。两者都有着自己的文档链接非常地详细，小白也可以很轻松地按照文档上地步骤搭建属于自己地博客。（在尝试中的最大的挑战可能就是网络的问题了）</p><p>下面是hexo和butterfly的文档链接：</p><ul><li><a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></li><li><a href="https://butterfly.js.org/">https://butterfly.js.org</a></li></ul><img src="/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.png" class="" title="alt text"><img src="/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/2.png" class="" title="alt text"><p>还有一些搭建中可能遇到的一些问题，可以参考下面的文章：</p><p>hexo本地博客+云服务器个人博客搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/m0_56112405/article/details/138262057</span><br></pre></td></tr></table></figure><p>Hexo-Butterfly音乐播放器的添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_41467882/article/details/124734598</span><br></pre></td></tr></table></figure><p>Hexo 博客部署到腾讯云服务器全流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/StaunchKai/article/details/82878928</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo 搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/04/hello-world/"/>
      <url>/2024/08/04/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
