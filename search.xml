<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP协议抓包分析</title>
      <link href="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tcp协议的分析"><a href="#tcp协议的分析" class="headerlink" title="tcp协议的分析"></a>tcp协议的分析</h1><p>TCP（传输控制协议）是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。它主要用于在网络中实现可靠的数据传输。TCP协议的主要特点和功能包括：</p><ol><li><strong>连接导向</strong>：TCP在数据传输之前需要建立一个连接。这通过三次握手过程来完成，以确保两端的通信双方都准备好进行数据传输。</li><li><strong>可靠性</strong>：TCP提供数据传输的可靠性。它使用确认（ACK）机制来确保数据包被成功接收。如果发送方在超时时间内没有收到确认，它会重新发送数据包。</li><li><strong>数据流控制</strong>：TCP使用流量控制机制来避免接收方的缓冲区溢出。接收方会告知发送方它可以接收的数据量，从而避免数据发送过快。</li><li><strong>拥塞控制</strong>：TCP能够检测网络拥塞，并通过减少数据发送速率来减轻网络拥塞。这有助于防止网络过载和数据包丢失。</li><li><strong>数据顺序保证</strong>：TCP确保数据包按发送顺序到达接收方。如果数据包到达的顺序与发送顺序不一致，TCP会重新排序数据包。</li><li><strong>错误检测和修正</strong>：TCP对传输中的数据进行错误检测，并要求重新传输丢失或损坏的数据包。</li></ol><p>这些功能使得TCP适用于需要高可靠性的应用，如网页浏览、电子邮件和文件传输等。</p><h2 id="有哪些协议是基于TCP协议来设计的？"><a href="#有哪些协议是基于TCP协议来设计的？" class="headerlink" title="有哪些协议是基于TCP协议来设计的？"></a>有哪些协议是基于TCP协议来设计的？</h2><p>基于TCP协议制定的协议主要包括各种应用层协议，这些协议利用TCP提供的可靠、面向连接的数据传输特性来实现特定的网络功能。以下是一些基于TCP协议的常见协议：</p><ol><li><strong>HTTP（Hypertext Transfer Protocol）</strong>：<ul><li>用于在Web浏览器和Web服务器之间传输网页和其他资源。</li><li>支持请求和响应模型，如GET、POST、PUT、DELETE等方法。</li></ul></li><li><strong>HTTPS（Hypertext Transfer Protocol Secure）</strong>：<ul><li>HTTP的安全版本，通过SSL&#x2F;TLS加密传输数据，确保数据在传输过程中的机密性和完整性。</li></ul></li><li><strong>FTP（File Transfer Protocol）</strong>：<ul><li>用于在网络上进行文件传输和管理。</li><li>支持多种操作，包括上传、下载、删除和重命名文件。</li></ul></li><li><strong>SMTP（Simple Mail Transfer Protocol）</strong>：<ul><li>用于发送电子邮件。</li><li>定义了邮件的格式和传输规则，从客户端发送邮件到邮件服务器，然后再转发到目标邮件服务器。</li></ul></li><li><strong>IMAP（Internet Message Access Protocol）</strong>：<ul><li>用于从邮件服务器检索邮件。</li><li>支持在邮件服务器上管理邮件的文件夹和邮件状态。</li></ul></li><li><strong>POP3（Post Office Protocol version 3）</strong>：<ul><li>用于从邮件服务器下载邮件。</li><li>邮件下载到客户端后通常会从服务器上删除，适用于简单的邮件接收需求。</li></ul></li><li><strong>Telnet</strong>：<ul><li>用于远程登录到另一台计算机上进行命令行操作。</li><li>允许用户在远程计算机上执行命令和管理系统。</li></ul></li><li><strong>SSH（Secure Shell）</strong>：<ul><li>用于安全的远程登录和执行命令。</li><li>提供加密和认证功能，确保远程会话的安全性。</li></ul></li><li><strong>SFTP（Secure File Transfer Protocol）</strong>：<ul><li>基于SSH的文件传输协议。</li><li>提供安全的文件传输和管理功能。</li></ul></li><li><strong>RDP（Remote Desktop Protocol）</strong>：<ul><li>用于通过网络远程访问Windows计算机的桌面环境。</li><li>允许用户在远程计算机上进行图形用户界面的操作。</li></ul></li></ol><p>常用的电脑协议端口包括以下几种，涵盖了多种网络服务和应用：</p><h3 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h3><ul><li><strong>20&#x2F;21 - FTP（File Transfer Protocol）</strong><ul><li><strong>20</strong>：FTP数据传输端口（被动模式时使用）。</li><li><strong>21</strong>：FTP控制端口（用于建立和管理连接）。</li></ul></li><li><strong>22 - SSH（Secure Shell）&#x2F;SFTP（Secure File Transfer Protocol）</strong><ul><li><strong>22</strong>：用于安全的远程登录和文件传输。</li></ul></li><li><strong>23 - Telnet</strong><ul><li><strong>23</strong>：用于远程登录服务（不加密，通常不推荐用于安全敏感的环境）。</li></ul></li><li><strong>25 - SMTP（Simple Mail Transfer Protocol）</strong><ul><li><strong>25</strong>：用于发送电子邮件。</li></ul></li><li><strong>53 - DNS（Domain Name System）</strong><ul><li><strong>53</strong>：用于域名解析服务。</li></ul></li><li><strong>67&#x2F;68 - DHCP（Dynamic Host Configuration Protocol）</strong><ul><li><strong>67</strong>：DHCP服务器端口。</li><li><strong>68</strong>：DHCP客户端端口。</li></ul></li><li><strong>80 - HTTP（Hypertext Transfer Protocol）</strong><ul><li><strong>80</strong>：用于Web服务（非加密）。</li></ul></li><li><strong>110 - POP3（Post Office Protocol version 3）</strong><ul><li><strong>110</strong>：用于接收电子邮件。</li></ul></li><li><strong>143 - IMAP（Internet Message Access Protocol）</strong><ul><li><strong>143</strong>：用于接收和管理电子邮件。</li></ul></li><li><strong>443 - HTTPS（Hypertext Transfer Protocol Secure）</strong><ul><li><strong>443</strong>：用于加密的Web服务。</li></ul></li><li><strong>3389 - RDP（Remote Desktop Protocol）</strong><ul><li><strong>3389</strong>：用于远程桌面连接（Windows系统）。</li></ul></li></ul><h3 id="三次握手（Three-Way-Handshake）"><a href="#三次握手（Three-Way-Handshake）" class="headerlink" title="三次握手（Three-Way Handshake）"></a>三次握手（Three-Way Handshake）</h3><p>TCP协议在建立连接时使用三次握手过程，确保双方都准备好进行数据传输。三次握手的步骤如下：</p><ol><li><strong>SYN</strong>：客户端向服务器发送一个SYN（同步）报文段，请求建立连接。此报文段包含客户端的初始序列号。</li><li><strong>SYN-ACK</strong>：服务器收到客户端的SYN报文段后，回复一个SYN-ACK（同步-确认）报文段。此报文段包含服务器的初始序列号，并确认收到客户端的SYN报文段。</li><li><strong>ACK</strong>：客户端收到服务器的SYN-ACK报文段后，发送一个ACK（确认）报文段，确认收到服务器的SYN报文段。此时，连接建立完成，双方可以开始数据传输。</li></ol><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><h3 id="四次挥手（Four-Way-Handshake）"><a href="#四次挥手（Four-Way-Handshake）" class="headerlink" title="四次挥手（Four-Way Handshake）"></a>四次挥手（Four-Way Handshake）</h3><p>TCP连接的终止过程使用四次挥手，以确保双方都完成了数据传输并可以安全地关闭连接。四次挥手的步骤如下：</p><ol><li><strong>FIN</strong>：发送方（例如客户端）发送一个FIN（结束）报文段，表示它已经完成了数据传输，并且没有更多的数据要发送。此时，发送方进入<strong>FIN_WAIT_1</strong>状态。</li><li><strong>ACK</strong>：接收方（例如服务器）收到FIN报文段后，发送一个ACK（确认）报文段，确认接收方已经收到FIN报文段。此时，接收方进入CLOSE_WAIT状态，发送方进入<strong>FIN_WAIT_2</strong>状态。</li><li><strong>FIN</strong>：接收方完成它的所有数据传输后，发送一个FIN报文段，表示它也没有更多的数据要发送。此时，接收方进入<strong>LAST_ACK</strong>状态，发送方收到此FIN报文段后，进入TIME_WAIT状态。</li><li><strong>ACK</strong>：发送方收到接收方的FIN报文段后，发送一个ACK报文段，确认接收到接收方的FIN报文段。此时，接收方进入<strong>CLOSED</strong>状态，发送方在超时后也进入CLOSED状态，连接完全关闭。</li></ol><p><strong>（典型的TCP四次挥手）</strong></p><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一次挥手：想要关闭连接的一方（在这里是服务器）会发送一个FIN报文给另一方（物理机），表示它已经没有数据要发送了，并且想要关闭连接。这个FIN报文是从服务器的22端口发送到物理机的某个随机高位端口的。</span><br><span class="line"></span><br><span class="line">第二次挥手：物理机在收到服务器的FIN报文后，会发送一个ACK报文作为应答，表示它已经收到了服务器的FIN报文。这个ACK报文是从物理机的那个随机高位端口发送到服务器的22端口的。</span><br><span class="line"></span><br><span class="line">第三次挥手（如果有必要）：在某些情况下，物理机也可能想要关闭连接，这时它会发送一个FIN报文给服务器。但是，在正常的SSH会话退出过程中，这一步通常不会发生，因为物理机通常不会主动关闭连接，除非它遇到了某种错误或异常。然而，如果物理机确实发送了FIN报文，那么这个报文也是从物理机的随机高位端口发送到服务器的22端口的。</span><br><span class="line"></span><br><span class="line">第四次挥手：服务器在收到物理机的FIN报文（如果有的话）或确认物理机已经收到了自己的FIN报文后（通过物理机发送的ACK报文），会发送一个ACK报文给物理机，表示它也已经准备好了关闭连接。这个ACK报文是从服务器的22端口发送到物理机的随机高位端口的。</span><br></pre></td></tr></table></figure><p><strong>（非典型的TCP四次挥手）</strong></p><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><h2 id="为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？"><a href="#为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？" class="headerlink" title="为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？"></a>为什么上图中抓到的报文不是典型的TCP四次挥手的报文呢？</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果你抓到的TCP四次挥手报文是由客户端（物理机）先发起的第一次挥手（即客户端发送FIN报文），那么这通常意味着SSH连接的关闭过程并非由服务器端的exit命令直接触发，而是由客户端或客户端上的某个进程/应用程序发起的。</span><br><span class="line"></span><br><span class="line">以下是一些可能导致客户端先发起FIN报文的原因：</span><br><span class="line"></span><br><span class="line">客户端主动关闭SSH会话：</span><br><span class="line">用户可能在客户端上使用了某种方式（如SSH客户端软件的关闭按钮、键盘快捷键、或执行了exit、logout等命令）来主动关闭SSH会话。这将导致客户端向服务器发送FIN报文来请求关闭TCP连接。</span><br><span class="line"></span><br><span class="line">客户端程序逻辑：</span><br><span class="line">如果SSH会话是由某个自动化脚本或程序启动的，并且该脚本或程序在完成其任务后包含了关闭SSH连接的逻辑，那么它可能会主动发送FIN报文来关闭连接。</span><br><span class="line"></span><br><span class="line">网络问题或中断：</span><br><span class="line">在极少数情况下，网络问题（如突然的网络断开、路由器故障等）可能导致TCP连接异常关闭，尽管这通常不会表现为标准的四次挥手过程。然而，如果客户端的网络堆栈检测到连接已经不可达，它可能会尝试发送FIN报文来优雅地关闭连接（尽管这通常不是网络问题导致的标准行为）。</span><br></pre></td></tr></table></figure><h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><ul><li><strong>SYN_SENT</strong>：连接请求已经发送，等待对方确认。</li><li><strong>SYN_RECEIVED</strong>：已经收到连接请求，并发送了确认。</li><li><strong>ESTABLISHED</strong>：连接已建立，可以进行数据传输。</li><li><strong>FIN_WAIT_1</strong>：等待对方确认连接关闭请求。</li><li><strong>FIN_WAIT_2</strong>：已经收到对方确认连接关闭请求，等待对方关闭连接。</li><li><strong>CLOSE_WAIT</strong>：对方关闭连接，等待应用程序关闭连接。</li><li><strong>LAST_ACK</strong>：等待对方确认最后一个关闭连接的请求。</li><li><strong>TIME_WAIT</strong>：等待足够的时间以确保对方收到关闭连接的确认。</li><li><strong>CLOSED</strong>：连接完全关闭。</li></ul><p>三次握手确保连接的双方能够可靠地建立通信，四次挥手确保连接能够被安全地关闭，避免数据丢失和资源浪费。</p><h2 id="wireshark抓包分析："><a href="#wireshark抓包分析：" class="headerlink" title="wireshark抓包分析："></a>wireshark抓包分析：</h2><p>​通过上面的阐述，我们可以了解到那些协议是基于TCP协议设计制定的。下面我们通过SSH连接来产生TCP报文，并通过wireshark来抓包分析其报文：</p><h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a><strong>三次握手：</strong></h4><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/5.png" class="" title="alt text"><img src="/2024/08/11/TCP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/6.png" class="" title="alt text"><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议抓包分析</title>
      <link href="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="icmp协议的分析"><a href="#icmp协议的分析" class="headerlink" title="icmp协议的分析"></a>icmp协议的分析</h2><p>ICMP（Internet Control Message Protocol，互联网控制报文协议）是网络设备用来发送错误消息和操作信息的协议，通常用于诊断网络连接问题。ICMP 是 TCP&#x2F;IP 协议族的一部分，主要用于主机与主机之间、主机与路由器之间以及路由器与路由器之间的通信。</p><h3 id="ICMP的主要功能"><a href="#ICMP的主要功能" class="headerlink" title="ICMP的主要功能"></a>ICMP的主要功能</h3><ol><li><strong>错误报告</strong>：<ul><li>当数据包不能到达目的地时，ICMP可以发送错误报告回源地址。例如，如果路由器找不到去往目的地的路由，它会发送一个“目标不可达”（Destination Unreachable）的ICMP消息。</li></ul></li><li><strong>网络诊断</strong>：<ul><li>ICMP常用于工具如<code>ping</code>和<code>traceroute</code>。<code>ping</code>使用ICMP回显请求和回显应答消息来检测网络连接是否可达，并测量往返时间。<code>traceroute</code>则通过逐步增加数据包的TTL（生存时间）来跟踪数据包的路径。</li></ul></li><li><strong>流量控制</strong>：<ul><li>ICMP可以发送“源抑制”（Source Quench）消息，通知发送方降低数据包发送速度，以避免网络过载。</li></ul></li></ol><h3 id="ICMP报文类型"><a href="#ICMP报文类型" class="headerlink" title="ICMP报文类型"></a>ICMP报文类型</h3><p>ICMP报文有多种类型，每种类型都有其特定的用途。常见的ICMP报文类型包括：</p><ul><li><strong>回显请求（Echo Request, 类型8）和回显应答（Echo Reply, 类型0）</strong>：用于<code>ping</code>操作。</li><li><strong>目标不可达（Destination Unreachable, 类型3）</strong>：表示数据包无法到达目的地。</li><li><strong>时间超时（Time Exceeded, 类型11）</strong>：用于指示数据包的TTL到达0时仍未到达目的地，一般在<code>traceroute</code>中使用。</li><li><strong>重定向（Redirect, 类型5）</strong>：通知主机应该使用另一条路由。</li></ul><h3 id="wireshark抓包分析"><a href="#wireshark抓包分析" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h3><p>我们可以在电脑的终端中ping我们的网关，再通过wireshark来抓到到icmp报文。</p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><p>wireshark抓包信息：</p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><p><strong>请求报文：</strong></p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><p><strong>应答报文：</strong></p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><p><strong>工作过程:</strong></p><p>本机发送一个 ICMP Echo Request 的包接受方返回一个ICMP Echo Reply，</p><p>包含了接受到数据拷贝和一些其他指令</p><h3 id="回显请求与应答报文的结构"><a href="#回显请求与应答报文的结构" class="headerlink" title="回显请求与应答报文的结构"></a>回显请求与应答报文的结构</h3><p>ICMP回显请求和应答报文的结构大致如下：</p><ul><li><strong>类型（Type）</strong>：8 表示回显请求，0 表示回显应答。</li><li><strong>代码（Code）</strong>：通常为 0。</li><li><strong>校验和（Checksum）</strong>：用于检测报文在传输中是否损坏。</li><li><strong>标识符（Identifier）</strong>：通常用来匹配请求和应答报文，允许区分不同的会话。</li><li><strong>序列号（Sequence Number）</strong>：用于跟踪报文的顺序，通常在多次请求中递增。</li><li><strong>数据（Data）</strong>：这是一个可选的填充字段，用于携带实际的数据。</li></ul><h3 id="数据字段的内容"><a href="#数据字段的内容" class="headerlink" title="数据字段的内容"></a>数据字段的内容</h3><p>在回显请求报文中，数据字段可以填充任何数据，常见的填充内容包括：</p><ul><li><strong>时间戳</strong>：用于计算往返时间。</li><li><strong>字符数据</strong>：例如，常见的填充数据为字符串，如“abcdefghijklmnopqrstuvwxyz”或简单的字节数据。</li><li><strong>随机数据</strong>：确保在网络传输中不会出现数据重复或重叠。<img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/5.png" class="" title="alt text"></li></ul><h2 id="icmp-中是如何来计算时间的？"><a href="#icmp-中是如何来计算时间的？" class="headerlink" title="icmp 中是如何来计算时间的？"></a>icmp 中是如何来计算时间的？</h2><p>ICMP 协议中的时间计算主要用于测量数据包在网络中的往返时间（Round-Trip Time, RTT），即一个 ICMP 回显请求（Echo Request）从发送到接收到相应的回显应答（Echo Reply）所经过的时间。这个时间的测量通常在网络诊断工具如 <code>ping</code> 中被使用。以下是 ICMP 中时间计算的过程：</p><h3 id="1-时间戳的记录"><a href="#1-时间戳的记录" class="headerlink" title="1. 时间戳的记录"></a>1. <strong>时间戳的记录</strong></h3><ul><li>当一个 ICMP 回显请求被发送时，发送方通常会在数据字段中记录一个时间戳。这通常是发送请求时的精确时间。</li><li>这个时间戳可以是系统的当前时间（例如以毫秒或微秒为单位的精确时间），具体格式取决于系统实现。</li></ul><h3 id="2-数据包的传输"><a href="#2-数据包的传输" class="headerlink" title="2. 数据包的传输"></a>2. <strong>数据包的传输</strong></h3><ul><li>ICMP 回显请求数据包从源主机发送到目标主机，经过可能的多个网络节点（如路由器）。</li><li>目标主机接收到请求后，会立即生成一个回显应答，将数据字段中的时间戳原封不动地返回给源主机。</li></ul><h3 id="3-应答的接收"><a href="#3-应答的接收" class="headerlink" title="3. 应答的接收"></a>3. <strong>应答的接收</strong></h3><ul><li><p>当源主机收到目标主机返回的 ICMP 回显应答时，它会读取应答报文中的时间戳。</p></li><li><p>计算RTT的方法是将当前时间与数据字段中的时间戳进行比较，即：</p><p>RTT&#x3D;接收应答的时间−发送请求的时间RTT &#x3D; \text{接收应答的时间} - \text{发送请求的时间}RTT&#x3D;接收应答的时间−发送请求的时间</p></li><li><p>这个时间差就是数据包在网络中的往返时间。</p></li></ul><h3 id="4-RTT-结果的显示"><a href="#4-RTT-结果的显示" class="headerlink" title="4. RTT 结果的显示"></a>4. <strong>RTT 结果的显示</strong></h3><ul><li><code>ping</code> 工具通常会显示每次请求的 RTT，以及多次请求的平均 RTT、最小 RTT 和最大 RTT。这些值可以帮助用户了解网络的性能和延迟情况。</li></ul><h4 id="TTL："><a href="#TTL：" class="headerlink" title="TTL："></a>TTL：</h4><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/6.png" class="" title="alt text"><h3 id="tracert-命令"><a href="#tracert-命令" class="headerlink" title="tracert 命令"></a>tracert 命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracert（trace Route）</span><br><span class="line">tracert + 设备ip</span><br></pre></td></tr></table></figure><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/7.png" class="" title="alt text"><p>如果数据包的跳数超过了设定的最大值（在 <code>tracert</code> 或 <code>traceroute</code> 命令中通常是 30 跳），则有几种可能的情况和影响：</p><ol><li><strong>路由环路</strong>：数据包可能进入一个环路状态，即它在两个或多个路由器之间不断循环。这会导致数据包永远不会到达目的地。</li><li><strong>目标不可达</strong>：如果数据包未能在最大跳数限制内到达目标，则认为目标网络不可达。这可能是由于网络配置错误或物理连接问题造成的。</li><li><strong>丢包</strong>：超过最大跳数的数据包通常会被网络中的一个路由器丢弃，并返回一个 ICMP 超时消息给发送者。</li><li><strong>延迟</strong>：数据包在多个跳数之间传输会导致增加的延迟，特别是在跨国或长距离的连接中。</li></ol><p><strong>一下tracert + 百度的公网IP：</strong></p><img src="/2024/08/08/ICMP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/8.png" class="" title="alt text"><p>从 <code>tracert</code> 输出中，我们可以看到：</p><ol><li>第一跳通过你的本地网关 <code>192.168.10.1</code>，延迟很低（2 毫秒）。</li><li>第二跳到达外部网络设备 <code>110.110.110.254</code>，延迟依旧非常低（平均约 2 毫秒）。</li><li>从第三跳开始，出现了请求超时，这表明数据包没有从下一个路由点成功返回，可能是因为网络配置问题、路由器故障或是某些网络设备配置了不响应 <code>tracert</code> 或 <code>ICMP</code> 请求。</li></ol><p>请求超时可能是因为：</p><ul><li>路由器或防火墙设置阻止了 ICMP 数据包。</li><li>网络链路故障或不稳定导致数据包无法传输。</li><li>路由配置问题导致数据包无法正确转发。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议抓包分析</title>
      <link href="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="wireshark-抓包分析"><a href="#wireshark-抓包分析" class="headerlink" title="wireshark 抓包分析"></a>wireshark 抓包分析</h1><h4 id="实战-使用-WireShark对常用协议抓包并分析原理"><a href="#实战-使用-WireShark对常用协议抓包并分析原理" class="headerlink" title="实战:使用 WireShark对常用协议抓包并分析原理"></a>实战:使用 WireShark对常用协议抓包并分析原理</h4><h3 id="1、常用协议分析"><a href="#1、常用协议分析" class="headerlink" title="1、常用协议分析"></a>1、常用协议分析</h3><p><strong>ARP 协议</strong></p><p>地址解析协议：(Address ResolutionProtocol，缩写:ARP)是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。<strong>ARP是通过网络地址（ip）来定位（确认）MAC地址。</strong></p><h3 id="一、ARP协议的基本概念"><a href="#一、ARP协议的基本概念" class="headerlink" title="一、ARP协议的基本概念"></a>一、ARP协议的基本概念</h3><ul><li><strong>定义</strong>：ARP协议是一个网络层协议，用于将网络层的IP地址解析成链路层的MAC地址，以便数据能在物理网络上正确传输。</li><li><strong>制定者</strong>：ARP协议由互联网工程任务组（IETF）在1982年11月发布的RFC 826中描述制定。</li><li><strong>作用</strong>：在TCP&#x2F;IP网络中，每个联网的主机都会被分配一个32位的IP地址，但为了让报文在物理网络上传输，还需要知道对方目的主机的物理地址（MAC地址）。ARP协议就是负责实现这一地址转换的。</li></ul><p><strong>抓包分析过程</strong></p><p>​过滤arp包：</p><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/1.png" class="" title="alt text"><h4 id="报文解析"><a href="#报文解析" class="headerlink" title="报文解析"></a>报文解析</h4><p>ARP（Address Resolution Protocol）协议的报文主要分为两种类型：<strong>ARP请求报文</strong>和<strong>ARP应答报文</strong>。下面我将分别举例分析这两种报文的结构和内容。</p><h5 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h5><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png" class="" title="alt text"><h5 id="应答报文："><a href="#应答报文：" class="headerlink" title="应答报文："></a>应答报文：</h5><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" class="" title="alt text"><h5 id="总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。"><a href="#总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。" class="headerlink" title="总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。"></a>总结：我们可以看到应答包补全了自己的mark地址目的地址和源地址做了替换。</h5><img src="/2024/08/07/ARP%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" class="" title="alt text"><p><strong>192.168.3.230广播:谁有 192.168.3.177 的 MAC地址?</strong></p><p><strong>192.168.3.177 应答:192.168.3.177 的 MAC 地址是 xxxxxxxxxxx</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建自己的博客</title>
      <link href="/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何来搭建自己的博客"><a href="#如何来搭建自己的博客" class="headerlink" title="如何来搭建自己的博客"></a>如何来搭建自己的博客</h1><p>​首先介绍介绍一下，本博客采用的是hexo框架搭配butterfly主题生成的。两者都有着自己的文档链接非常地详细，小白也可以很轻松地按照文档上地步骤搭建属于自己地博客。（在尝试中的最大的挑战可能就是网络的问题了）</p><p>下面是hexo和butterfly的文档链接：</p><ul><li><a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></li><li><a href="https://butterfly.js.org/">https://butterfly.js.org</a></li></ul><img src="/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.png" class="" title="alt text"><img src="/2024/08/06/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/2.png" class="" title="alt text"><p>还有一些搭建中可能遇到的一些问题，可以参考下面的文章：</p><p>hexo本地博客+云服务器个人博客搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/m0_56112405/article/details/138262057</span><br></pre></td></tr></table></figure><p>Hexo-Butterfly音乐播放器的添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_41467882/article/details/124734598</span><br></pre></td></tr></table></figure><p>Hexo 博客部署到腾讯云服务器全流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/StaunchKai/article/details/82878928</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/04/hello-world/"/>
      <url>/2024/08/04/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
